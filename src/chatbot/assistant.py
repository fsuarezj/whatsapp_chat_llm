from .mixins.diagram_drawer_mixin import DiagramDrawerMixin
from .base_state import BaseState

from .agents.shop_assistant import ShopAssistant
#from .agents.agents_mixins.cost_calculator_mixin import Costs

from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
from langgraph.errors import GraphRecursionError
from langchain_core.messages import HumanMessage
from langchain_core.messages.ai import AIMessage

from loguru import logger
#from pandas import Series
from dotenv import load_dotenv
from pprint import pformat
import uuid
import os
import types
import json

#from myformassistant.exception_logger import configure_excepthook
#configure_excepthook()

class Assistant(DiagramDrawerMixin):
    """
    Assistant class orchestrates the flow of processing questionnaires 
    by utilizing different agents and managing the state graph.
    """

    def __init__(self):
        """
        Initialize the chatbot by setting up the environment and state graph.
        """
        load_dotenv()
        super().__init__()
        self._graph = self._init_graph()
        self._config = {
            "configurable": {
                "thread_id": str(uuid.uuid4()),
            },
            "recursion_limit": 25
        }

    def _get_state(self):
        """
        Retrieve the current state from the state graph.
        """
        return self._graph.get_state(self._config)

    def _init_graph(self):
        """
        Initialize the state graph with agents and their connections.

        The state graph is a directed graph where each node represents an agent and
        each edge represents a transition between agents. The graph is used to
        determine the sequence of agents that will be executed for a given input.
        """
        # Create the state graph
        builder = StateGraph(BaseState)
        # Add nodes to the graph
        builder.add_node("shopAssistant", ShopAssistant())
        builder.set_entry_point("shopAssistant")
        # Add edges to the graph
        builder.add_edge("shopAssistant", END)
        # Add checkpointer
        memory = MemorySaver()
        return builder.compile(checkpointer=memory)

    #def get_costs(self) -> Series:
    #    """
    #    Get the total costs associated with the operations.
    #    """
    #    costs = Series(Costs.get_total_costs())
    #    return costs

    def generate_stream_response(self, input):
        """
        Generate a stream response for the given input.

        The stream response is generated by passing the input to the state graph and
        yielding the messages and state changes that result from the graph's processing.

        To avoid infinite recursion, the graph's recursion limit is increased each time
        a `GraphRecursionError` is encountered, until a maximum of 100 is reached.

        Args:
            input (str): The input to the graph.
            state (types.SimpleNamespace): A namespace to store the state of the graph.

        Yields:
            str: The messages and state changes that result from the graph's processing.
        """
        events = self._graph.stream({"messages": ("user", input)}, self._config, stream_mode="values")
        for event in events:
            message = event.get("messages")
            
            if isinstance(message, list):
                # If the message is a list, take the last element
                message = message[-1]
                
            msg_repr = message.pretty_repr(html=False)
            
            if not isinstance(message, HumanMessage):
                # Yield the state and message
                yield message.content
                #yield '\n\r'
